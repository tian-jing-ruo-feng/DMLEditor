import { useDiagramStore } from '@/stores/useDiagramStore';

export function generateSQL(options: {
  dbType: string;
  includeComments: boolean;
  includeDropStatements: boolean;
}): string {
  const diagramStore = useDiagramStore();
  const { dbType, includeComments, includeDropStatements } = options;
  
  let sql = '';
  
  // 添加头部注释
  if (includeComments) {
    sql += `-- Database Model: ${diagramStore.projectName}\n`;
    sql += `-- Generated by Database Modeler\n`;
    sql += `-- Database Type: ${dbType}\n\n`;
  }
  
  // 生成 DROP 语句
  if (includeDropStatements) {
    diagramStore.tables.forEach(table => {
      sql += `DROP TABLE IF EXISTS ${escapeIdentifier(table.name, dbType)};\n`;
    });
    sql += '\n';
  }
  
  // 生成 CREATE TABLE 语句
  diagramStore.tables.forEach(table => {
    // 表注释
    if (includeComments && table.comment) {
      sql += `-- ${table.comment}\n`;
    }
    
    sql += `CREATE TABLE ${escapeIdentifier(table.name, dbType)} (\n`;
    
    // 字段定义
    const columns = table.fields.map(field => {
      let columnDef = `  ${escapeIdentifier(field.name, dbType)} ${getTypeDefinition(field.type, dbType)}`;
      
      if (field.primaryKey) {
        columnDef += ' PRIMARY KEY';
      }
      
      if (field.notNull) {
        columnDef += ' NOT NULL';
      }
      
      return columnDef;
    });
    
    sql += columns.join(',\n');
    sql += '\n);\n\n';
  });
  
  // 生成外键约束
  diagramStore.relations.forEach(relation => {
    const sourceTable = diagramStore.tables.find(t => t.id === relation.source);
    const targetTable = diagramStore.tables.find(t => t.id === relation.target);
    
    if (sourceTable && targetTable) {
      if (includeComments && relation.comment) {
        sql += `-- ${relation.comment}\n`;
      }
      
      const constraintName = `fk_${sourceTable.name}_${relation.sourceField}_to_${targetTable.name}_${relation.targetField}`;
      
      sql += `ALTER TABLE ${escapeIdentifier(sourceTable.name, dbType)}\n`;
      sql += `  ADD CONSTRAINT ${escapeIdentifier(constraintName, dbType)}\n`;
      sql += `  FOREIGN KEY (${escapeIdentifier(relation.sourceField, dbType)})\n`;
      sql += `  REFERENCES ${escapeIdentifier(targetTable.name, dbType)} (${escapeIdentifier(relation.targetField, dbType)});\n\n`;
    }
  });
  
  return sql;
}

function escapeIdentifier(name: string, dbType: string): string {
  switch (dbType) {
    case 'mysql':
      return `\`${name}\``;
    case 'postgresql':
    case 'sqlserver':
      return `"${name}"`;
    case 'oracle':
      return `"${name.toUpperCase()}"`;
    default:
      return name;
  }
}

function getTypeDefinition(type: string, dbType: string): string {
  const typeMappings: Record<string, Record<string, string>> = {
    mysql: {
      INT: 'INT',
      VARCHAR: 'VARCHAR(255)',
      TEXT: 'TEXT',
      DATE: 'DATE',
      DATETIME: 'DATETIME',
      TIMESTAMP: 'TIMESTAMP',
      BOOLEAN: 'TINYINT(1)',
      FLOAT: 'FLOAT',
      DOUBLE: 'DOUBLE',
      DECIMAL: 'DECIMAL(10,2)',
      BLOB: 'BLOB',
      JSON: 'JSON'
    },
    postgresql: {
      INT: 'INTEGER',
      VARCHAR: 'VARCHAR(255)',
      TEXT: 'TEXT',
      DATE: 'DATE',
      DATETIME: 'TIMESTAMP',
      TIMESTAMP: 'TIMESTAMP',
      BOOLEAN: 'BOOLEAN',
      FLOAT: 'REAL',
      DOUBLE: 'DOUBLE PRECISION',
      DECIMAL: 'DECIMAL(10,2)',
      BLOB: 'BYTEA',
      JSON: 'JSONB'
    },
    sqlserver: {
      INT: 'INT',
      VARCHAR: 'VARCHAR(255)',
      TEXT: 'TEXT',
      DATE: 'DATE',
      DATETIME: 'DATETIME',
      TIMESTAMP: 'DATETIME2',
      BOOLEAN: 'BIT',
      FLOAT: 'FLOAT',
      DOUBLE: 'FLOAT',
      DECIMAL: 'DECIMAL(10,2)',
      BLOB: 'VARBINARY(MAX)',
      JSON: 'NVARCHAR(MAX)'
    },
    oracle: {
      INT: 'NUMBER',
      VARCHAR: 'VARCHAR2(255)',
      TEXT: 'CLOB',
      DATE: 'DATE',
      DATETIME: 'TIMESTAMP',
      TIMESTAMP: 'TIMESTAMP',
      BOOLEAN: 'NUMBER(1)',
      FLOAT: 'BINARY_FLOAT',
      DOUBLE: 'BINARY_DOUBLE',
      DECIMAL: 'NUMBER(10,2)',
      BLOB: 'BLOB',
      JSON: 'CLOB'
    },
    sqlite: {
      INT: 'INTEGER',
      VARCHAR: 'TEXT',
      TEXT: 'TEXT',
      DATE: 'TEXT',
      DATETIME: 'TEXT',
      TIMESTAMP: 'TEXT',
      BOOLEAN: 'INTEGER',
      FLOAT: 'REAL',
      DOUBLE: 'REAL',
      DECIMAL: 'REAL',
      BLOB: 'BLOB',
      JSON: 'TEXT'
    }
  };
  
  return typeMappings[dbType]?.[type.toUpperCase()] || type;
}